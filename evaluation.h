/*
    ROME (ReadOut Modelling Environment)
    Copyright Â© 2017  Rudolf Schimassek (rudolf.schimassek@kit.edu),
                      Felix Ehrler (felix.ehrler@kit.edu),
                      Karlsruhe Institute of Technology (KIT)
                                - ASIC and Detector Laboratory (ADL)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 3 as 
    published by the Free Software Foundation.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    This file is part of the ROME simulation framework.
*/

#ifndef _EVALUATION
#define _EVALUATION

#include <vector>
#include <iostream>
#include <string>
#include <stdlib.h>
#include <sstream>
#include <fstream>
#include <vector>

#include "TGraph.h"
#include "TH1.h"
#include "TH1I.h"
#include "TH2.h"
#include "TH2I.h"
#include "TCanvas.h"
#include "TAxis.h"
#include "TPaletteAxis.h"
#include "TList.h"
#include "TLegend.h"

#include "hit.cpp"

#if __cplusplus >= 201103L  //C++11 support 
  #include "zip_file.cpp"
  #define mycpp11support
#endif

class Evaluation
{
public:
    enum source {Input = 0, Pass = 1, Fail = 2};

    enum operations {Smaller        =  1,
                     SmallerEqual   =  2,
                     Equal          =  3,
                     NotEqual       =  4,
                     Larger         =  5,
                     LargerEqual    =  6};

    Evaluation();

    /**
     * @brief loads data from the EventGenerator's output file
     * @details
     * 
     * @param filename       - the file to load from
     * @return               - the number of Hit objects loaded
     */
    int     LoadInputHits(std::string filename);
    /**
     * @brief loads data from the EventGenertor's output file in an archive
     * @details
     * 
     * @param archivename    - file name of the archive
     * @param filename       - name of the file in the archive
     * 
     * @return               - the number of Hit objects loaded
     */
    #ifdef mycpp11support
      int     LoadInputHits(std::string archivename, std::string filename);
    #endif
    /**
     * @brief loads data for successfully read out hits from a file
     * @details
     * 
     * @param filename       - the file to load from
     * @return               - the number of Hit objects loaded
     */
    int     LoadPassedOutputHits(std::string filename);
    /**
     * @brief loads data for successfully read out hits from an archive
     * @details
     * 
     * @param archivename    - file name of the archive
     * @param filename       - name of the file in the archive
     * 
     * @return               - the number of Hit objects loaded
     */
    #ifdef mycpp11support
      int     LoadPassedOutputHits(std::string archivename, std::string filename);
    #endif
    /**
     * @brief loads data for Hits lost during the simulation
     * @details
     * 
     * @param filename       - the file to load from
     * @return               - the number of Hit object loaded
     */
    int     LoadFailedOutputHits(std::string filename);
    /**
     * @brief loads data for Hits lost during the simulation from an archive
     * @details
     * 
     * @param archivename    - file name of the archive
     * @param filename       - name of the file in the archive
     * 
     * @return               - the number of Hit objects loaded
     */
    #ifdef mycpp11support
      int     LoadFailedOutputHits(std::string archivename, std::string filename);
    #endif

    /**
     * @brief provides a Hit object from one of the three sources (EventGenerator, Read Hits, 
     *             Lost Hits).
     * @details
     * 
     * @param index          - the index of the Hit object in the vector
     * @param input          - the source of the Hit:
     *                            Input = Hits generated by the EventGenerator
     *                            Pass  = successfully read out hits
     *                            Fail  = lost hits
     * 
     * @return               - the hit object requested or an invalid hit for an index out of range
     */
    Hit     GetHit(unsigned int index, int input = Pass);
    /**
     * @brief adds a Hit object to the evaluation structure
     * @details
     * 
     * @param hit            - the Hit object to add
     * @param input          - sets whether it is a Pass, Fail or Input hit
     * 
     * @return               - the number of hits added (in this case 1)
     */
    int     InsertHits(Hit hit, int input = Pass);
    /**
     * @brief adds several hits to the evaluation structure, but all to the same category
     * @details
     * 
     * @param hits           - the Hit objects to add
     * @param input          - the category the Hits belong to (Pass, Fail, Input)
     * 
     * @return               - the number of Hit objects added (size of the vector)
     */
    int     InsertHits(std::vector<Hit>& hits, int input = Pass);
    /**
     * @brief removes all hits from the specified category
     * @details
     * 
     * @param input          - the category of hits to remove (Pass, Fail, Input)
     */
    void    ClearHits(int input = Pass);

    /**
     * @brief counts the hits in the passed category
     * @details
     * 
     * @param input          - the category of the hits to count (Pass, Fail, Input)
     * @return               - the number of hits in the category
     */
    int     GetNumHits(int input = Pass);

    /**
     * @brief generates a scatter plot from the data provided (for options for xaxis and yaxis,
     *             see description of GetDoubleValue())
     * @details
     * 
     * @param xaxis          - the field of the Hit objects to use as x-coordinate
     * @param yaxis          - the field of the Hit objects to use as y-coordinate
     * @param input          - the category of data to use for the plot (Pass, Fail, Input)
     * @return               - the resulting TGraph (unformated)
     */
    TGraph* GenerateScatterplot(std::string xaxis, std::string yaxis, int input = Pass);

    /**
     * @brief generates a histogram from a property of the hit objects (for options
     *             see description of GetDoubleValue())
     * @details
     * 
     * @param value          - the property of the Hit objects to use
     * @param start          - the lower edge of the first bin
     * @param end            - the upper edge of the last bin
     * @param binwidth       - width of a single bin
     * @param input          - the category of data to use (Pass, Fail, Input)
     * @return               - the resulting histogram
     */
    TH1*    GenerateHistogram(std::string value,
                                    double start, double end, double binwidth, int input = Pass);

    /**
     * @brief a special histogram allowing to histogram differences of times (even though all 
     *             fields of the Hit objects are accessible)
     * @details
     * 
     * @param firsttime      - the earlier time to use for the time difference (see description
     *                            of GetDoubleValue()) for options)
     * @param secondtime     - the later time to use for the time difference (same as above)
     * @param start          - lower edge of the first bin
     * @param end            - upper edge of the last bin
     * @param binwidth       - width of a single bin
     * @param input          - category of data to use (Pass, Fail, Input)
     * @return               - the unformatted delay histogram
     */
    TH1*    GenerateDelayHistogram(std::string firsttime, std::string secondtime,
                                    double start, double end, double binwidth, int input = Pass);

    /**
     * @brief calculates the integral of the histogram and normalises the result to be 1 for the
     *             integral over the whole histogram
     * @details
     * 
     * @param histogram      - the histogram to generate the integration curve from
     * @return               - a TGraph containing the integration curve
     */
    TGraph* GenerateIntegrationCurve(TH1* histogram);

    /**
     * @brief removes Hits from a Hit vector using a logic operation on any property of the hit
     *             objects. The hit is kept when the logic operation returns true.
     * @details
     * 
     * @param field          - the property of the hit object to use (for options see 
     *                            GetDoubleValue())
     * @param operation      - the logic operation to use (for options see enum operations)
     * @param value          - the right value of the logic operation
     * @param input          - the vector to use (Input, Pass, Fail)
     * @return               - the number of hits left in the vector
     */
    int FilterEvents(std::string field, int operation, double value, int input = Pass);

    /**
     * @brief takes an object, formats it and generates the plot in a new window
     * @details
     * 
     * @param graph          - the graph to plot
     * @param xtitle         - title for the x axis
     * @param ytitle         - title for the y axis
     * @param options        - drawing options for the ROOT Draw[Clone]() method
     * @param leg            - optional pointer to a TLegend object. If provided, an entry for the
     *                            object to draw is added with option "p" for graphs, "l" for
     *                            histograms and "f" for 2D histograms
     * @param legtitle       - text to write in the legend entry, not used if leg == 0
     * 
     * @return               - a pointer to the canvas used to plot the graph
     */
    TCanvas* Plot(TGraph* graph, std::string xtitle, std::string ytitle, 
                                    std::string options = "AP*", TLegend* leg = 0,
                                    std::string legtitle = "");
    TCanvas* Plot(TH1* histogram, std::string xtitle, std::string ytitle, 
                                    std::string options = "", TLegend* leg = 0,
                                    std::string legtitle = "");
    TCanvas* Plot(TH2* histogram, std::string xtitle, std::string ytitle, std::string ztitle, 
                    std::string options = "colz", TLegend* leg = 0, std::string legtitle = "");

    /**
     * @brief adds a plot to an existing canvas. No formatting is done on the graph/histogram
     * @details
     * 
     * @param canvas         - the canvas to add the plot to. For canvas=0, the method aborts
     * @param graph          - the graph to plot into the canvas
     * @param options        - drawing options for the graph. Do NOT include "A" for printing axes.
     *                            the "same" option can be omitted
     * @param leg            - pointer to a TLegend object. If provided, an entry for the object to
     *                            draw is added to it
     * @param legtitle       - caption of the legend entry
     * 
     * @return               - the canvas which was provided in `canvas`
     */
    TCanvas* AddPlot(TCanvas* canvas, TGraph* graph, std::string options = "P*", TLegend* leg = 0,
                                    std::string legtitle = "");
    TCanvas* AddPlot(TCanvas* canvas, TH1* histogram, std::string options = "", TLegend* leg = 0,
                                    std::string legtitle = "");
    TCanvas* AddPlot(TCanvas* canvas, TH2* histogram, std::string options = "colz", 
                                    TLegend* leg = 0, std::string legtitle = "");

    /**
     * @brief adds a legend to the plot
     * @details
     * 
     * @param canvas         - the canvas to add the legend into
     * @param legend         - the legend itself
     * 
     * @return               - the canvas provided
     */
    TCanvas* AddLegend(TCanvas* canvas, TLegend* legend);

    /**
     * @brief extracts all hits from the group hit provided using a dictionary provided
     * @details
     * 
     * @param encoding       - the map connecting the codes with the actual addresses. First comes
     *                            the real address and second the code
     * @param hit            - the group hit object to analyse for all contained hits
     * 
     * @return               - a vector containing all hits as decoded with the provided encoding
     */
    std::vector<Hit> SeparateHit(std::map<int, int>& encoding, Hit& hit, 
                                    std::string addrname = "PixelDiode");
    /**
     * @brief replaces the contents of a hit category with its decoded data representation
     * @details
     * 
     * @param encoding       - the map connecting the codes with the actual addresses. First comes
     *                            the real address and second the code
     * @param addrname       - the address field to use for the decoding
     * @param input          - the category to use for the evaluation
     * 
     * @return               - the resulting number of hits
     */
    int              SeparateHits(std::map<int, int>& encoding, std::string addrname = "PixelDiode",
                                    int input = Pass);

    /**
     * @brief generates a map for 1 Bit per Pixel encoding. Indices from 1 to `pixels` are
     *             associated with the bits in a binary number.
     * @details
     * 
     * @param pixels         - the number of pixels to prepare for
     * @return               - the map for the separation of hits
     */
    static std::map<int, int> GetBinaryEncoding(int pixels);
private:
    /**
     * @brief opens the input file and loads the Hit objects contained into the passed vector
     * @details
     * 
     * @param vec            - the vector to write the loaded hits to
     * @param filename       - filename to load the data from
     * 
     * @return               - the number of Hit objects loaded
     */
    int LoadHits(std::vector<Hit>* vec, std::string filename);
    /**
     * @brief loads hit data from a stringstream instead of a file
     * @details
     * 
     * @param vec            - the vector to write the loaded hits to
     * @param filecontents   - data stream containing the data
     * 
     * @return               - the number of Hit objects loaded
     */
    int LoadHits(std::vector<Hit>* vec, std::stringstream& filecontents);
    /**
     * @brief provides the vector corresponding to the category of data
     * @details
     * 
     * @param input          - the category of data (Pass, Fail, Input)
     * @return               - the vector containing the hit objects of the chosen category
     */
    std::vector<Hit>*   GetVectorPointer(int input);

    /**
     * @brief returns the value of a field of the Hit object as a double value
     * @details
     * 
     * @param hit            - the Hit object to extract the data from
     * @param value          - description of the field to return. Options are:
     *                            * eventid     - the ID the hit belongs to
     *                            * charge      - the charge deposited in the pixel
     *                            * deadtime    - the deadtime of the pixel induced by this hit
     *                            * timestamp   - the starting time of the hit
     *                            * deadtimeend - absolute end time of the dead time
     *                            * addr...     - with this prefix to any address name it can be
     *                                               obtained
     *                            * TS...       - with this prefix to any address name the
     *                                               corresponding readout time stamp can be 
     *                                               obtained
     *                         between "addr" or "TS" and the address name is no additional
     *                              character - for example the pixel's address can be accesses
     *                              with "addrpixel" (assuming the pixel's address name is "pixel")
     * 
     * @return               - the value of the field chosen with `value` or "-1" in case of a
     *                            non-existing field
     */
    double GetDoubleValue(Hit& hit, std::string value);
    /**
     * @brief returns the value of a field of the Hit object as an integer value
     * @details
     * 
     * @param hit            - the Hit object to extract the data from
     * @param value          - field name (see GetDoubleValue())
     * 
     * @return               - the value of the field or "-1" on a non-existing field name
     */
    int    GetIntValue(Hit& hit, std::string value);

    std::vector<Hit>    input;
    std::vector<Hit>    outputpass;
    std::vector<Hit>    outputfail;

};


#endif  //_EVALUATION
